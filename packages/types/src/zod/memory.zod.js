// Generated by ts-to-zod
import { z } from "zod";
import { vADStateSchema, timestampSchema, accessMetricsSchema, importanceScoreSchema, memoryOperationSchema, } from "./common.zod";
export const workingMemoryTurnSchema = z.object({
    id: z.string(),
    role: z.union([
        z.literal("user"),
        z.literal("assistant"),
        z.literal("system"),
    ]),
    content: z.string(),
    timestamp: z.string(),
    tokens: z.number(),
    character_id: z.string().optional(),
});
export const workingMemorySchema = z.object({
    turns: z.array(workingMemoryTurnSchema),
    max_turns: z.number(),
    total_tokens: z.number(),
});
export const characterSchema = timestampSchema.extend({
    id: z.string(),
    name: z.string(),
    type: z.literal("Character"),
    emotional_state: vADStateSchema,
});
export const factVersionSchema = z.object({
    value: z.string(),
    timestamp: z.string(),
    confidence: z.number().optional(),
});
export const factNodeSchema = timestampSchema.extend({
    id: z.string(),
    entity: z.string(),
    attribute: z.string(),
    current_value: z.string(),
    history: z.array(factVersionSchema),
    importance_score: z.number(),
});
export const relationshipEdgeSchema = timestampSchema.extend({
    id: z.string(),
    from_entity: z.string(),
    to_entity: z.string(),
    relationship_type: z.string(),
    strength: z.number(),
    emotional_context: vADStateSchema.optional(),
});
export const vectorMetadataSchema = timestampSchema
    .extend(accessMetricsSchema.shape)
    .extend(importanceScoreSchema.shape)
    .extend({
    doc_id: z.string(),
    source_session_id: z.string(),
    content_type: z.union([
        z.literal("summary"),
        z.literal("insight"),
        z.literal("event"),
    ]),
    tags: z.array(z.string()),
});
export const vectorMemoryFragmentSchema = z.object({
    id: z.string(),
    embedding: z.array(z.number()),
    content: z.string(),
    metadata: vectorMetadataSchema,
    similarity_score: z.number().optional(),
});
export const vectorMemorySchema = z.object({
    fragments: z.array(vectorMemoryFragmentSchema),
    dimension: z.number(),
    index_size: z.number(),
});
export const l1RetrievalResultSchema = z.object({
    turns: z.array(workingMemoryTurnSchema),
    relevance_score: z.number(),
    token_count: z.number(),
});
export const l2RetrievalResultSchema = z.object({
    characters: z.array(characterSchema),
    facts: z.array(factNodeSchema),
    relationships: z.array(relationshipEdgeSchema),
    relevance_score: z.number(),
    token_count: z.number(),
});
export const l3RetrievalResultSchema = z.object({
    fragments: z.array(vectorMemoryFragmentSchema),
    relevance_score: z.number(),
    token_count: z.number(),
});
export const memoryRetrievalResultSchema = z.object({
    l1: l1RetrievalResultSchema,
    l2: l2RetrievalResultSchema,
    l3: l3RetrievalResultSchema,
    fusion_weights: z.object({
        w_L1: z.number(),
        w_L2: z.number(),
        w_L3: z.number(),
    }),
    final_score: z.number(),
    total_tokens: z.number(),
});
export const factWriteResultSchema = z.object({
    operations: z.array(memoryOperationSchema),
    fact_ids: z.array(z.string()),
});
export const relationshipWriteResultSchema = z.object({
    operations: z.array(memoryOperationSchema),
    relationship_ids: z.array(z.string()),
});
